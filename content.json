[{"title":"配置PodSpec.文件容易遇到的问题","date":"2018-11-01T01:43:08.383Z","path":"2018/11/01/配置PodSpec.文件容易遇到的问题/配置PodSpec.文件容易遇到的问题/","text":"前言:相信大部分的iOS程序员都想将自己写的工具上传到cocoaPods供大家使用，网上关于这方面的教程已经太多太多了，但是如果你真正亲自去实践一次，你就会发现里面有很多坑等着你，并不像别人说的轻轻松松就把代码托管到了cocoaPods上面，最近闲来无事，我在经过无数次失败以后，终于使自己的PodSpec.文件通过了验证，这里我将自己遇到的坑给大家列出来，希望能够帮到那些有这方面需求的程序猿。 一:第一坑，所有需要验证的PodSpec.文件都必须要打tag值，不然不能通过验证。(注意:每次打的tag值必须比上次打的tag值大，而且你的版本号也不能小于你的tag值，不然也不能验证通过) 二:第二坑,所有的配置文件验证都是跟github上面的代码进行对比的，所以在修改了本地PodSpec.文件以后，请先上传代码到github再进行 pod lib lint 命令验证 三:第三坑,公开头文件的目录请用单引号括起来,如下: 四:如果你在终端中出现了以下显示，证明你的项目已经发布成功了 五:一般情况下，在你提交成功以后，其实还是不能再终端中通过pod search 命令搜索到你托管的第三方的，你需要到cocoapods去认领你的第三方传送门 六:之后就一直等待发布一段时间，然后就能在cocoapods上面搜索到你的第三方了(注：有时候还是搜索不出来你发布第三方，我们这个时候就可以只通过名字来搜索你的第三方 ) pod search +三方名 + simple (注:一开始我只能通过上面那种+simple的方式搜索出来，我当时是怀疑是自己的图片资源放在项目中，但是并没有在spec文件中设置规则来约束它，因为我的spec文件在进行验证的过程中报警告了，最后操作了一番，不需要加simple也能搜索出来了。) (1): 如果还是搜索不出来那就执行 pod setup 发现显示的还是 Unable to find a pod with name, author, summary, or descriptionmatching ‘LFBPageScrollView’。 (2)：如果搜索不出来那就更新pod : 命令: pod repo update 然后就是等待更新结果 (3): 这个时候咱们就将生成的json文件给删除了 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件。 终端输入rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行pod search (4):执行pod search 终端输入：pod search LFBPageScrollView(不区分大小写) 输出：Creating search index for spec repo ‘master’.. Done!，稍等片刻就会出现所有带LFBPageScrollView字段的类库出现；如果在这种情况下还是搜索不到你的第三方，那么你就只有再仔细检查一下，你之前哪里做的不对。 关于如何更新版本的问题: 在很多时候，我们需要更新迭代我们发布的第三方，我们这个时候只需要做以下几件事就可以轻松的更新原来的东西。 1.需要将spec文件拷贝过来 2.将spec的version 和tag 都改一下 3.通过git打一个新的大于以前的tag值 4.通过pod spec lint 来验证spec文件是否有效 5.将新的spec文件推送到cocoapods上面去 6.再次到cocoapods官网去认领自己的第三方(注:朋友说需要再次领取，也有人说不需要再次认领，不需要再次认领的情况我还是没尝试过，等我试过以后再给大家分享。) 最后再送上的第三方名字LFBPageScrollView,大家在用过以后遇到什么问题，都可以向我反馈。我会继续迭代……. 注:(转载请注明出处!!!)","tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"https://github.com/LiuFuBo1991/tags/黑魔法/"}]},{"title":"同步锁解决方案","date":"2018-04-11T02:04:53.000Z","path":"2018/04/11/同步锁解决方案/同步锁解决方案/","text":"前言:&nbsp;&nbsp;在Objective-C中，如果有多个线程要执行同一份代码，那么有时候会出问题。这种情况下，通常使用锁来实现某种同步机制。在GCD出现之前，有两种方法，第一种采用内置的”同步块”(synchronization block): -(void)synchronizedMethod{ @synchronized(self){ //Safe}} &nbsp;&nbsp;这种写法会根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕。执行到这段代码结尾处，锁就释放了。在本例中，同步行为所针对的对象是self。这么写通常没错，因为它可以保证每个对象实例都能不受干扰地运行其synchronizedMethod方法。然而，滥用@synchronized(self)则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。若是在self对象上频繁加锁，那么程序可能等另一段与此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。 另一个办法是直接使用NSLock对象： _lock = [[NSLock alloc] init]; -(void)synchronizedMethod{ [_lock lock]; //Safe [_lock unlock];} &nbsp;&nbsp;也可以使用NSRecursiveLock 这种递归锁(recursive lock)，线程能够多次持有该锁，而不会出现死锁(deadlock)现象。&nbsp;&nbsp;这两种方法都很好，不过也有其缺陷。比方说，在极端情况下，同步块会导致死锁，另外，其效率也不见得很高，而如果直接使用锁对象的话，一旦遇到死锁，就会非常麻烦。&nbsp;&nbsp;替代方案就是使用GCD，它能以更简单、更高效的形式为代码加锁。比方说，属性就是开发者经常需要同步的地方，这种属性需要做成原子的。用atomic特性来修饰属性，即可实现这一点。而开发者如果想自己编写访问方法的话，那么通常会这样写： -(void)someString{ @synchronized(self){ return _someString;}} -(void)setSomeString:(NSString *)someString{ @synchronized(self){ _someString = someString;}} &nbsp;&nbsp;刚才说过，滥用@synchronized(self)会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行，这也许并不是开发者想要的效果。我们只是想令每个属性各自独立地同步。&nbsp;&nbsp;顺便说一下，这么做虽然能提供某种程度的线程安全，但却无法保证访问该对象时该对象绝对是线程安全的。当然，访问属性的操作确实是原子的。使用属性时，必定能从中获取到有效值，然而在同一个线程上多次调用获取方法（getter），每次获取到的结果却未必相同。在两次访问操作之间，其他线程可能会写入新的属性值。&nbsp;&nbsp;有种简单而高效的方法可以替代同步块或锁对象，那就是使用”串行同步队列”（serial synchronization queue）。将读取操作以及写入操作都安排在同一个队列中，即可保证数据同步。其用法如下： _syncQueue = dispatch_queue_create(“com.effective.syncQueue”,NULL);-(NSString )someString{ __block NSString localSomeString; dispatch_sync(_syncQueue,^{ localSomeString = _someString;});}-(void)setSomeString:(NSString *)someString{ dispatch_sync(_syncQueue,^{ _someString = someString;});}&nbsp;&nbsp;此模式的思路是：把设置操作与获取操作都安排在序列化队列里执行，这样的话，所有针对属性的访问操作就都同步了。为了使块代码能够设置局部变量，获取方法中用到了__block语法，若是抛开这一点，那么这种写法要比前面那些更为简洁。全部加锁任务都在GCD中处理，而GCD是在相当深的底层来实现的，于是能够做许多优化。因此，开发者无须担心那些事，只要专心把访问方法写好就行。&nbsp;&nbsp;然而还可以进一步优化。设置方法并不一定非得是同步的。设置实例变量所用的块，并不需要想设置方法返回什么值。也就是说，设置方法的代码可以改成下面这样: -(void)setSomeString:(NSString *)someString{ dispatch_async(_syncQueue,^{ _someString = someString;});} &nbsp;&nbsp;这次只是把同步派发改成了异步派发，从调用者的角度来看，这个小改动可以提升设置方法的执行速度，而读取操作与写入操作依然会按顺序执行。但这么改有个坏处：如果你测一下程序性能，那么可能会发现这种写法比原来慢，因为执行异步派发时，需要拷贝块。若拷贝块所用的事件明显超过执行块所花的事件，则这种做法将比原来更慢。由于本书所举的这个例子很简单，所以改完之后很可能会变慢。然而，若是派发给队列的块要执行更为繁重的任务，那么仍然可以考虑这种备选方案。&nbsp;&nbsp;多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行，利用这个特点，还能写出更快一些的代码来。此时正可以提现GCD写法的好处来。用同步块或锁对象，是无法轻易实现下面这种方案的。这次不用串行队列，而改用并发队列。(concurrent queue) _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);-(NSString )someString{ __block NSString localSomeString; dispatch_sync(_syncQueue,^{ localSomeString = _someString;});}-(void)setSomeString:(NSString *)someString{ dispatch_async(_syncQueue,^{ _someString = someString;});} &nbsp;&nbsp;像现在这样写代码，还无法正确实现同步。所有读操作与写入操作都会在同一个队列中执行，不过由于是并发队列，所以读取与写入操作可以随时执行。而我们恰恰不想让这些操作随意执行。此问题用一个简单的GCD功能即可解决，它就是栅栏(barrier)。下列函数可以向队列中派发块，将其作为栅栏使用： void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block); &nbsp;&nbsp;在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个执行的。并发队列如果发现接下来要处理的块是个栅栏块(barrier block)，那么就一直要等待当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方法继续向下处理。 &nbsp;&nbsp;在本例中，可以用栅栏块来实现属性的设置方法。在设置方法中使用了栅栏块之后，对属性的读取操作依然可以并发执行，但是写入操作却必须单独执行了。实现代码如下: _syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);-(NSString )someString{ __block NSString localSomeString; dispatch_sync(_syncQueue,^{ localSomeString = _someString;}); return localSomeString;}-(void)setSomeString:(NSString *)someString{ dispatch_barrier_async(_syncQueue,^{ _someString = someString;});} 在这个并发队列中，读取操作是用普通的块来实现的，而写入操作则是用栅栏块来实现的。读取操作可以并行，但写入操作必须单独执行，因为它是栅栏块 &nbsp;&nbsp;测试一下性能，你就会发现，这种做法肯定比使用串行队列要快。注意设置函数也可以改用同步的栅栏块（synchronous barrier）来实现，那样做可能会更高效，原因执行异步派发，需要拷贝块。最好还是测一测每种做法的性能，然后从中选出最适合当前场景的方案。 总结: *派发队列可用来表示同步语义(synchronization semantic)，这种做法要比使用@synchronized块或NSLock对象更简单 *将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 *使用同步队列及栅栏块，可以令同步块行为更为高效。总之，多用派发队列，少用同步锁。","tags":[{"name":"同步","slug":"同步","permalink":"https://github.com/LiuFuBo1991/tags/同步/"},{"name":"异步","slug":"异步","permalink":"https://github.com/LiuFuBo1991/tags/异步/"},{"name":"同步块","slug":"同步块","permalink":"https://github.com/LiuFuBo1991/tags/同步块/"},{"name":"递归锁","slug":"递归锁","permalink":"https://github.com/LiuFuBo1991/tags/递归锁/"},{"name":"死锁","slug":"死锁","permalink":"https://github.com/LiuFuBo1991/tags/死锁/"},{"name":"栅栏块","slug":"栅栏块","permalink":"https://github.com/LiuFuBo1991/tags/栅栏块/"},{"name":"串行队列","slug":"串行队列","permalink":"https://github.com/LiuFuBo1991/tags/串行队列/"},{"name":"并行队列","slug":"并行队列","permalink":"https://github.com/LiuFuBo1991/tags/并行队列/"}]},{"title":"sourcetree的使用","date":"2017-12-12T04:26:13.000Z","path":"2017/12/12/sourcetree的使用/index/","text":"前言：&nbsp;&nbsp;在平时开发过程中，我们难免会跟sourcetree打交道，很多人都会用sourcetree来合并代码，所以掌握好sourcetree的使用，有时候显得格外重要，这里我列出平时会用到的一些操作，希望能对各位有所帮助。 一:创建新的分支方法一:1.通过点击分支右键选择新建分支2.当弹出新建分支和删除分支的框来时，此时只需要输入新的分支名就可以创建好了方法二:1.直接点击最上面的分支图标，弹出新建和删除分支页面2.在弹出的新建分支框中输入新的分支名就可以创建好了3.创建好以后需要将新的分支和原来旧的分支上的代码进行合并，此时先选中当前新建分支，然后找到下面远端你需要合并的分支名右键点击它，拉取检出该分支代码到当前分支上4.当前新分支跟旧的分支代码合并以后，此时新创建的分支还只存在于本地，我们此时需要将该分支推送到远程服务器存储起来此时咱们的新分支就在远程服务器上展示出来了 二:拉取别人的分支1.在平时的开发过程中，不一定新分支是自己创建的，所以在别人已经把新分支已经创建好并合并了你当前分支代码的情况下，你需要切换到跟对方同一个分支上去开发代码，我们只需要选择下面远端某一个别人创建的分支，右键点击检出2.此时,你就可以看到当前分支上多了一个分支，并且该分支被选中为当前分支完成以后就可以轻松的跟别人在同一个分支上提交代码了。 三:合并别人的分支项目开发过程中，可能因为一些原因需要几个人在不同的分支上开发，最后再统一合并代码，这个时候就需要用到合并，此时假如我想把4.7.0的代码合并到4.8.1上面。 1.确保当前分支在4.8.1的情况下，单机选中4.7.1的分支，右键选中合并4.7.0至4.8.1合并完以后，我们可以看到自己项目中OC代码多了4.7.0的代码，同理想要将4.8.1合并到其他分支上也是这样操作，当前最后不要忘记将最新合并分支的代码推送到远程服务器端 四:解决合并冲突问题咱们在小的分支上完成开发以后，需要将代码最终合并到master分支上，例如现在现在除了master还有两个分支A、B，当master跟A合并以后没有出现问题，但是在跟B合并以后，出现了冲突，这是因为A和B同时对同一块代码进行了修改。有冲突就要解决，右键单击冲突文件，选择解决冲突，这里有两个选项：1、使用 我的版本 解决冲突2、使用 他人版本 解决冲突这里首先是将A的分支合并到主分支master，那么“我的版本”就是对应的A的，“他人版本”对应的就是B的。如果首先合并B的分支，那么对应关系就要对调一下。总的来说，“我的版本”对应的是首先合并到主分支master的。采用一个人的版本，那么在冲突文件中就只会保留该人修改的代码，例如我这里就选择”使用 我的版本 解决冲突“，那么在master中就只会保留A分支添加的代码。（针对冲突部分） 这里采用网络图片做一个示意图:到此为止，分支问题基本搞定,当然，如果你在运用过程中遇到任何问题，也欢迎你前来issue 我,我会为你做更详细的解答。","tags":[{"name":"分支","slug":"分支","permalink":"https://github.com/LiuFuBo1991/tags/分支/"},{"name":"合并","slug":"合并","permalink":"https://github.com/LiuFuBo1991/tags/合并/"},{"name":"冲突","slug":"冲突","permalink":"https://github.com/LiuFuBo1991/tags/冲突/"}]},{"title":"iOS事件的传递和响应链","date":"2017-09-30T08:50:00.000Z","path":"2017/09/30/iOS事件的传递和响应链/index/","text":"前言:&nbsp;&nbsp;在咱们平时的开发过程中，每天都在敲着带有各种响应事件的代码，那咱们iOS的响应事件是怎样传递的呢？系统是怎样找到发出该事件的控件并执行响应方法的？为此，我写下这篇文章算是自己对事件响应链的学习的理解和总结吧！希望对在这方面有疑惑的你有帮助。 在iOS中有好几类，咱们今天只分析一下平时用的最多的触摸事件，学习触摸事件首先要了解一个比较重要的概念，响应者对象(UIResponder) 概念:在iOS中并不是任何对象都能处理事件，只有继承自UIResponder的对象才能接受并处理事件，我们称之为”响应者对象”。UIApplication、UIViewController、UIView这些都是继承自UIResponder的，所以他们都能接受并处理事件。 一:为什么继承自UIResponder的类能接收和处理事件呢？那是因为UIResponder提供了以下方法来处理事件： - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件 - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 - (void)remoteControlReceivedWithEvent:(UIEvent *)event; 通过上面的阐述在了解哪些控件能接收和处理事件以及它们为什么能处理事件以后，咱们需要了解到事件的产生和传递的过程是怎样的 二:事件的产生和传递2.1 事件的产生 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 2.2事件的传递 触摸事件的传递是从父控件传递到子控件 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view注 意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 三:App是如何找到最合适的控件来处理事件呢？1.首先咱们的App在刚进入应用的时候会首先创建UIApplication对象，它是一个单例，在任何页面都能拿到它，当咱们点击一个视图UIView的时候，产生一个触摸事件A，这个触摸事件A会被添加到UIApplication的队列中，然后UIApplication会把事件A传递给应用程序的主窗口(keyWindow)2.判断触摸点是否在自己身上3.如果触摸点在自己身上，那就遍历自己的子控件数组，记得是从后往前遍历，因为最后加载上去的视图放在最上面，从后往前遍历会使遍历次数更少，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）4。如果子控件没有任何一个符合条件的，那么系统就会认为它自己是最合适处理这个事件的控件，这是最适合的View。 为了演示具体的传递过程是怎么样的，这里盗用网上的一张示意图来展示: 上面演示的意思就是假如现在有一个fitView，点击fitView在调用系统方法 - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { } 发现触摸点在fitView身上，那么系统就会将fitView的子控件倒序遍历一遍，如果找到能够符合该触摸事件的控件，就交给该控件执行响应的触摸方法，如果没有子控件符合要求，那就默认fitView为符合该条件的View UIView不能接收触摸事件的三种情况： 1.不允许交互：userInteractionEnabled = NO;2.隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件3.透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 四:寻找最适合的View的详细分析在详细讲解之前，需要了解两个重要的方法: 1.- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{} 2.- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{} 第一个方法事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法 hitTest:withEvent:方法作用: 寻找并返回最合适的view(能够响应事件的那个最合适的view)注 意：不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法 拦截事件的处理 正因为hitTest：withEvent：方法可以返回最合适的view，所以可以通过重写hitTest：withEvent：方法，返回指定的view作为最合适的view。不管点击哪里，最合适的view都是hitTest：withEvent：方法中返回的那个view。通过重写hitTest：withEvent：，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。事件传递给谁，就会调用谁的hitTest:withEvent:方法。 事件传递给窗口或控件的后，就调用hitTest:withEvent:方法寻找更合适的view。所以是，先传递事件，再根据事件在自己身上找更合适的view。不管子控件是不是最合适的view，系统默认都要先把事件传递给子控件，经过子控件调用自己的hitTest:withEvent:方法验证后才知道有没有更合适的view。即便父控件是最合适的view了，子控件的hitTest:withEvent:方法还是会调用，不然怎么知道有没有更合适的！即，如果确定最终父控件是最合适的view，那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的。技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！ 原因在于在自己的hitTest:withEvent:方法中返回自己有时候会出现问题。因为会存在这么一种情况：当遍历子控件时，如果触摸点不在子控件A自己身上而是在子控件B身上，还要要求返回子控件A作为最合适的view，采用返回自己的方法可能会导致还没有来得及遍历A自己，就有可能已经遍历了点真正所在的view，也就是B。这就导致了返回的不是自己而是触摸点真正所在的view。所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！ 注意:hitTest：withEvent:方法会在底层调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。 五:响应者链条的工作原理当用户点击屏幕产生一个触摸事件以后，经过一系列的事件传递，会找到最合适的视图控件来处理这个事件，找到最合适的视图控件以后，就会调用控件的touches方法来做具体的事件处理，而这些touches方法的默认做法是将事件顺着响应者链条向上传递，在代码上的最直接的展示如下: //只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件 // 上一个响应者可能是父控件 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ // 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理 [super touchesBegan:touches withEvent:event]; // 注意不是调用父控件的touches方法，而是调用父类的touches方法 // super是父类 superview是父控件 } 在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法，所以我们可以利用这个原理，做到一个事件多个对象处理，我们只需要在重写touches方法的时候，除了写自己需要处理的代码，同时调用[super touchesBegan:touches withEvent:event],将事件响应再交给父类处理。 经过上面的分析，咱们可以轻易的得出结论：事件的传递方式是从上往下(父控件到子控件),事件的响应方式是从下往上(顺着响应者链条，向上传递，从子控件到父控件)。 *注:以上观点是本人参考别人文章后所作的总结和感悟，如有雷同，存属正常！","tags":[{"name":"事件","slug":"事件","permalink":"https://github.com/LiuFuBo1991/tags/事件/"},{"name":"传递","slug":"传递","permalink":"https://github.com/LiuFuBo1991/tags/传递/"},{"name":"响应者链","slug":"响应者链","permalink":"https://github.com/LiuFuBo1991/tags/响应者链/"},{"name":"UIResponder","slug":"UIResponder","permalink":"https://github.com/LiuFuBo1991/tags/UIResponder/"}]},{"title":"GCD中判断线程内容执行完毕","date":"2017-08-18T11:34:22.000Z","path":"2017/08/18/GCD中判断线程内容执行完毕/GCD中判断线程内容执行完毕/","text":"前言:&nbsp;&nbsp;在使用GCD多线程做操作时，有些时候需要咱们多线程里面的内容全部完成以后，再去刷新页面内容，这种情况下就需要咱们知道什么时候多线程队列里面的内容已经执行完毕，这里列举三种方法，希望能对有需要的小伙伴有启发。 一：信号量信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。 在GCD中有三个函数是semaphore的操作，分别是：dispatch_semaphore_create 创建一个semaphoredispatch_semaphore_signal 发送一个信号dispatch_semaphore_wait 等待信号 第一个函数是创建一个信号量，我们会给它一个初始值，第二个函数是发送信号量，当调用该函数的时候，信号量的值会加一，第三方函数是等待信号量，调用等待信号量以后信号量的值会减一，并且当信号量的值小于0时，线程就会一直等待，直到信号量的值大于等于0时才能继续执行。 咱们下面逐一介绍这三个函数的调用以及参数意义 1.dispatch_semaphore_create dispatch_samaphore_t dispatch_semaphore_create(long value); 传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。 值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。 2.dispatch_semaphore_signal long dispatch_semaphore_signal(dispatch_semaphore_tdsema) 这里的参数是第一个函数创建的信号 3.dispatch_semaphore_wait long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)； 第一参数的是信号，第二个参数是超时时间的设定，系统给我们了两 种超时时间设定，一种是 DISPATCH_TIME_NOW 表示当前； DISPATCH_TIME_FOREVER 表示遥远的未来；你可以选择其中一种也可以自己创建一个超时时间函数 创建超时timeout有两种方法 第一种方法： dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)； 其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。 第二种方式: dispatch_time_t dispatch_walltime(&lt;#const struct timespec * _Nullable when, int64_t delta); 其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。 6.关于信号量，一般可以用停车来比喻。 网吧剩余6个座位，那么即使同时来了6个人也能同时接待。如果此时来了7个人，那么就有一个人需要等待。 信号量的值就相当于剩余座位的数目，dispatch_semaphore_wait函数就相当于来了一个人，dispatch_semaphore_signal 就相当于走了一个人。网络座位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value））， 调用一次dispatch_semaphore_signal，剩余的座位就增加一个；调用一次dispatch_semaphore_wait剩余座位就减少一个； 当剩余座位为0时，再来人（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几个人等待一个座位。有些人 没有耐心，给自己设定了一段等待时间，这段时间内等不到座位就走了，如果等到了就去上网。而有些人就想站在这里，所以就一直等下去。 具体到代码中假设咱们现在需要做完A、B、事件以后才能去做C事件那么咱们就可以仿照下面的做法 #import &quot;ViewController.h&quot; #import &lt;objc/runtime.h&gt; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; [self initlizeAppeareces]; } - (void)initlizeAppeareces{ //crate的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //任务1 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;办理A事件&quot;); dispatch_semaphore_signal(semaphore); }); //任务2 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;办理B事件&quot;); dispatch_semaphore_signal(semaphore); }); } 当咱们信号量为2时，证明之前的事件都办理完了，咱们就可以做其他的事情了。 二：队列加group分组dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 执行1个耗时的异步操作 }); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 执行1个耗时的异步操作 }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 等前面的异步操作都执行完毕后，回到主线程... }); 当程序执行dispatch_group_notify()函数时，证明队列中的任务已经执行完了。 第三种方式dispatch_barrier_sync和dispatch_barrier_async共同点： 1、等待在它前面插入队列的任务先执行完 2、等待他们自己的任务执行完再执行后面的任务 不同点： 1、dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们 2、dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。 所以调用这两种方法中的其中一个都会等前面的方法执行完以后再执行之后的方法，就可以确定队列中任务是否完成 注： 在信号量的demo编写过程中我发现当信号量等于0的时候都崩溃了,如果有知道原因的老铁欢迎前来分享。","tags":[{"name":"GCD","slug":"GCD","permalink":"https://github.com/LiuFuBo1991/tags/GCD/"},{"name":"信号量","slug":"信号量","permalink":"https://github.com/LiuFuBo1991/tags/信号量/"},{"name":"队列","slug":"队列","permalink":"https://github.com/LiuFuBo1991/tags/队列/"},{"name":"Group","slug":"Group","permalink":"https://github.com/LiuFuBo1991/tags/Group/"}]},{"title":"NSInvocation的基本用法","date":"2017-08-18T11:22:11.000Z","path":"2017/08/18/NSInvocation的基本用法/NSInvocation的基本用法/","text":"小知识:在 iOS中可以直接调用某个对象的消息方式有两种：一种是performSelector:withObject；再一种就是NSInvocation。 为什么这么说呢，首先某个对象指的实例化后的对象，对象所对应的方法，则指的是实例方法。在一个类中调用另一个类的实例方法，只有上面两种方式。第一种方式比较简单，能完成简单的调用。但是对于&gt;2个的参数或者有返回值的处理，那performSelector:withObject就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作 NSInvocation的基本使用 一、直接调用当前类对象消息 方法签名类 // 方法签名中保存了方法的名称/参数/返回值，协同 NSInvocation来进行消息的转发 // 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系 //1、根据方法来初始化NSMethodSignature NSMethodSignature *signature = [ViewController instanceMethodSignatureForSelector:@selector(run:)]; 根据方法签名来创建NSInvocation对象 // NSInvocation中保存了方法所属的对象/方法名称/参数/返回值 //其实NSInvocation就是将一个方法变成一个对象 //2、创建NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; //设置方法调用者 invocation.target = self; //注意：这里的方法名一定要与方法签名类中的方法一致 invocation.selector = @selector(run:); NSString *way = @&quot;byCar&quot;; //这里的Index要从2开始，以为0跟1已经被占据了，分 别是 self（target）,selector(_cmd) [invocation setArgument:&amp;way atIndex:2]; //3、调用invoke方法 [invocation invoke]; //实现run:方法 - (void)run:(NSString *)method{ } 二、在当前VC调用其他类对象消息 这里咱们假设一种情况需要在VC控制器中调用继承自NSObject的ClassBVc类中的run方法,并且要向该方法传递参数。 ClassBVc.h文件实现 #import &lt;UIKit/UIKit.h&gt; @interface ClassBVc : UIViewController - (void)run:(NSString *)parames; @end ClassBVc.m文件实现 #import &quot;ClassBVc.h&quot; @interface ClassBVc () @end @implementation ClassBVc - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } - (void)run:(NSString *)parames{ NSLog(@&quot;你猜我猜不猜?%@&quot;,parames); } VC.m文件实现 #import &quot;ViewController.h&quot; #import &quot;ClassBVc.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; ClassBVc *B = [[ClassBVc alloc]init]; // 方法签名中保存了方法的名称/参数/返回值，协同 NSInvocation来进行消息的转发 // 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系 //1、根据方法来初始化NSMethodSignature NSMethodSignature *signature = [ClassBVc instanceMethodSignatureForSelector:@selector(run:)]; // NSInvocation中保存了方法所属的对象/方法名称/参数/返回值 //其实NSInvocation就是将一个方法变成一个对象 //2、创建NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; //设置方法调用者 invocation.target = B; //注意：这里的方法名一定要与方法签名类中的方法一致 invocation.selector = @selector(run:); NSString *way = @&quot;byCar&quot;; //这里的Index要从2开始，以为0跟1已经被占据了，分 别是self（target）,selector(_cmd) [invocation setArgument:&amp;way atIndex:2]; //3、调用invoke方法 [invocation invoke]; } 最终运行结果: NSInvocation在项目中最重要的使用场景在消息转发上面，如果在做消息转发时你没有实现resolveClassMethod:或者forwardingTargetForSelector:方法，那么系统就会来到最后拦截的第三道屏障，当你实现methodSignatureForSelector:方法以后，系统会触发forwardInvocation:方法；在forwardInvocation:方法中你可以修改目标的接受者等等。 下面咱们来复现该场景： 假设现在有一个VC控制器、两个继承自NSObject的Target类和boy类，现在咱们需要在VC里面调用Target的methodC方法，但是在Target类里面我只写了methodC方法的声明，并没有在.m中实现它，但是我在Boy.m类中实现了methodC方法，现在需要做到的就是在调用Target方法时，触发Boy类中methodC的实现。 VC.m文件中的实现: #import &quot;ViewController.h&quot; #import &quot;Target.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Target *targets = [[Target alloc]init]; [targets methodC]; } Target.h文件中中的实现 #import &lt;Foundation/Foundation.h&gt; @interface Target : NSObject - (void)methodC; @end Target.m文件中把消息转发给了Boy类来执行 #import &quot;Target.h&quot; #import &quot;Boy.h&quot; #import &lt;objc/runtime.h&gt; @implementation Target //methodSignatureForSelector用来生成方法签名，这个签 名就是给forwardInvocation中的参数NSInvocation调用的。 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) { if ([Boy instancesRespondToSelector:aSelector]) { signature = [Boy instanceMethodSignatureForSelector:aSelector]; } } return signature; } //所以我们需要做的是自己新建方法签名，再在forwardInvocation中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。 - (void)forwardInvocation:(NSInvocation *)anInvocation{ if ([Boy instancesRespondToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:[Boy new]]; } } Boy.h文件中没有实现 #import &lt;Foundation/Foundation.h&gt; @interface Boy : NSObject @end Boy.m文件中实现了methodC方法 #import &quot;Boy.h&quot; @implementation Boy - (void)methodC{ NSLog(@&quot;爱我你就抱抱我&quot;); } @end 从上面可以看到，当咱们去调用类中没有找到实现方法的时候，如果我们在消息转发的过程中重写了那些方法，就可以实现一些特定的需求。 具体的demo地址在我个人github上面，如果有需要的朋友欢迎下载-&gt;传送门","tags":[{"name":"runtime","slug":"runtime","permalink":"https://github.com/LiuFuBo1991/tags/runtime/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"https://github.com/LiuFuBo1991/tags/NSInvocation/"},{"name":"performaSelector","slug":"performaSelector","permalink":"https://github.com/LiuFuBo1991/tags/performaSelector/"}]},{"title":"Objective-c方法调用流程","date":"2017-08-18T11:11:04.000Z","path":"2017/08/18/Objective-c方法调用流程/Objective-c方法调用流程/","text":"前言:&nbsp;&nbsp;前段时间去面试，每个面试官都问到了OC中方法是如何调用的；感觉自己答到点子上了，但是回答的并不是很完善，所以我特地抽时间将这部分知识点重新看了一遍，算是最自己所学的一个总结吧！ Objective-c是一门动态语言，动态两个字主要就体现在我们调用方法的时候，运行时回动态的查找方法，然后调用相应的函数地址。运行时是整个Objective-c程序的基石，有了它我们的程序才能正常运行起来。 对于OC的方法调用，有两个重点需要掌握：1.对于OC中一切的方法调用，最终都会转换为类似下面的C语言函数 id objc_msgSend(id self, SEL op, . . .); 2.对象的方法调用传递过程，Objective-c中每个类对象最开始的位置都会有一个isa指针，该指针指向一个结点，其实就是一个链表，该链表主要包含两部分信息： (1).指向父类的指针。(2).自身的函数分发表。 有了这两部分，Objective-c的方法的调用流程就可以跑起来了。当我们调用一个对象的某一个方法的时候，首先会在当前类的分发表中寻找该方法，如果找不到对应的方法，然后再去其父类中寻找该方法，依次类推直到找到对应的方法为止，流程图如下： 当OC要调用方法时，会沿着这个链表一路查找，直到在函数分发表中找到要调用的函数为止。当然runtime会对这个过程进行优化，来缓存已经调用过得函数地址，不至于让我们每次都又沿着链表查找一遍,当程序运行一次以后再次调用就会更加高效。 通过学习官方文档Objective-C Runtime Programming Guide可以发现所有的方法调用最后都转化为了C语言函数调用，例如：我们创建了一个ClassA类型对象person，然后调用try方法，[person try],在编译的时候，编译器就会将该方法转化为objc_msgSend(person,selector)的形式，runtime会调用try方法实现所对应的函数地址，该函数所对应的两个参数，其中第一个参数指向调用该方法的对象，第二个参数则代表要调用的方法。 上面说到objc_msgSend函数首先会根据消息接受者对象的isa指针找到它的真实类型，然后在该类的方法列表中查找是否有与当前选择器相对应的方法，如果没有就跳转到父类中去查找，当查找到元类NSObject还是没有找到的时候，就会执行消息转发流程，我们接下来就继续讨论运行时消息转发是怎么回事。 消息转发消息转发流程比较复杂，主要分为三个步骤，首先我们需要先来看一张消息转发的流程图。 第一步 当消息派发流程最终在对象的元类中都没有找到对应的方法选择器时，就会开启消息转发流程，如果是实例方法的话，第一步会先调用消息接受者所在类的resolveInstanceMethod:方法，如果是类方法的话则会调用resolveClassMethod:，这两个方法的返回值都是BOOL值，表示是否动态添加一个方法来响应当前消息选择器。 + (BOOL)resolveInstanceMethod:(SEL)sel; + (BOOL)resolveClassMethod:(SEL)sel; 以上两个方法均声明在NSObject类中，如果消息接收者所在类重写了这两个方法中的其中一个方法并返回YES，也就意味着想要动态添加一个方法来响应当前的消息选择器，可以在重写的方法内使用class_addMethod函数来为当前类添加方法。 BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) 该函数第一个参数代表为哪个类添加方法，第二个参数是方法所对应的选择器，第三个参数是C语言的函数指针，用来指向待添加的方法，最后一个参数表示待添加方法的类型编码（详情可查看苹果官方文档：Objective-C Runtime Programming Guide）。 第二步 如果上一步过程中，并没有新方法能响应消息选择器，则会进入消息转发流程的第二步。在第二步中系统会调用当前消息接收者所在类的forwardingTargetForSelector:方法，用以询问能否将该条消息发送给其他接收者来处理，方法的返回值就代表这个新的接收者，如果不允许将消息转发给其他接收者则返回nil。 - (id)forwardingTargetForSelector:(SEL)aSelector; 利用这个方法，我们再使用组合可以模拟多重继承，在其他类中重写forwardingTargetForSelector:将其他类所能响应的消息选择器的接收者设置成当前类，这样当前类就可以拥有其他类的方法或者属性。 第三步 如果forwardingTargetForSelector:方法的返回值为nil，那么消息转发机制还要继续进行最后一步。在这一步中，系统会将尚未处理的消息包装成一个NSInvocation对象，其内部包含与该消息相关的所有信息，比如消息的选择器、目标接收者、参数等。之后系统会调用消息接收者所在类的forwardInvocation:方法，并将生成的NSInvocation对象作为参数传入。 - (void)forwardInvocation:(NSInvocation *)anInvocation; forwardInvocation:方法同样声明在NSObject类中，我们可以重写该方法的实现。比如将NSInvocation对象的target属性设置为其他接收者，此操作可以实现与上一步操作同样的效果，但明显在效率上没有第二步的操作高，所以很少有人在这一步中仅仅只是改变消息的接收者。NSInvocation类中还提供了许多属性和方法用于修改其对应方法的信息，比如可以修改方法的参数和返回值，或者直接更改消息选择器转而调用其他方法。 最后如果消息接收者在这一步中仍然无法响应消息选择器，那么系统会自动调用doesNotRecognizeSelector:方法，该方法默认实现为抛出异常，也就是我们在开发中经常见到的unrecognized selector sent to instance。 -[ViewController count]: unrecognized selector sent to instance","tags":[{"name":"runtime","slug":"runtime","permalink":"https://github.com/LiuFuBo1991/tags/runtime/"},{"name":"Invocation","slug":"Invocation","permalink":"https://github.com/LiuFuBo1991/tags/Invocation/"},{"name":"isa","slug":"isa","permalink":"https://github.com/LiuFuBo1991/tags/isa/"}]},{"title":"socket套接字编程","date":"2017-07-24T08:23:16.000Z","path":"2017/07/24/socket套接字编程/socket套接字编程/","text":"前言&nbsp;&nbsp;之前面试中，很多面试官都会问socket套接字的用法，可能有很多老铁跟我一样对于socket的原理有点懵逼，恰好最近公司的项目中用到socket长连接，这里我将我总结的一些经验分享给大家，希望对初学者有用。 要向弄懂socket得用法需要知道以下知识点: 1.套接字的概念 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 2.国际OSI七层结构网络从上往下分为：应用层、表示层、会话层、传输层、网络层、数据链路层、以及物理层，其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；表示层和应用层则被称作主机层，是用户所面向和关心的内容。 3.OSI七层结构的各自作用（1）应用层：与其他计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。示例：telnet，HTTP,FTP,WWW,NFS,SMTP等。（2）表示层：这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASII格式，发送方将把文本从发送方的字符集转换成标准的ASII后发送数据。在接收方将标准的ASII转换成接收方计算机的字符集。示例：加密，ASII等。（3）会话层：他定义了如何开始、控制和结束一个会话，包括对多个双向小时的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。（4）传输层：这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。（5）网络层：这层对端到端的包传输进行定义，他定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP,IPX等。（6）数据链路层：他定义了在单个链路上如何传输数据。这些协议与被讨论的歌种介质有关。示例：ATM，FDDI等。（7）物理层：OSI的物理层规范是有关传输介质的特性标准，这些规范通常也参考了其他组织制定的标准。连接头、针、针的使用、电流、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。 4.网络中的各个协议:TCP/IP、TCP/IP、SOCKET等的关系 Http协议对应于应用层;Tcp协议对应于传输层;IP协议对应于网络层;TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。我们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层 协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 5.Http和Socket连接区别相信不少初学手机联网开发的朋友都想知道Http与Socket连接究竟有什么区别，希望通过自己的浅显理解能对初学者有所帮助。 TCP连接要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手；握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手” 四次挥手: &nbsp;&nbsp;假设Client端发起中断连接请求，也就是发送FIN报文；因为正常情况下FIN同步报文和ACK确认标志是一起发送的，但是因为在断开链接的时候，可能出现服务器端还有一些数据没有传输完，所以就将同步报文和确认标志分开传输给客户端；Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ HTTP连接HTTP协议即超文本传送协议(HypertextTransferProtocol )是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。1.在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2.在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 建立socket连接 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 SOCKET连接与TCP连接创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 Socket连接与HTTP连接由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。","tags":[{"name":"套接字","slug":"套接字","permalink":"https://github.com/LiuFuBo1991/tags/套接字/"},{"name":"长连接","slug":"长连接","permalink":"https://github.com/LiuFuBo1991/tags/长连接/"},{"name":"http协议","slug":"http协议","permalink":"https://github.com/LiuFuBo1991/tags/http协议/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"https://github.com/LiuFuBo1991/tags/TCP-IP协议/"},{"name":"OSI七层网络结构","slug":"OSI七层网络结构","permalink":"https://github.com/LiuFuBo1991/tags/OSI七层网络结构/"}]},{"title":"同步、异步与串行、并行的关系","date":"2017-07-13T06:51:07.000Z","path":"2017/07/13/同步、异步与串行、并行的关系/同步、异步与串行、并行的关系/","text":"前言:做这块知识展示目的是为了帮助自己对多线程中的知识点做一个回顾，所以可能讲解上面会很简单，但是重点是要将知识点弄清晰，如果你对多线程不是很了解，那么可以看看，当然本文中如果存在错误，也欢迎大家指正。 多线程中的队列:串行队列、 并行队列、全局队列、主队列执行的方法：同步执行和异步执行线程分类:单线程和多线程,咱们平时用的最多的就是GCD和NSOperation,他们之间的核心区别在于GCD是将一个任务添加到队列中，然后指定任务执行的方法，而NSOperation则是将一个操作添加到队列中。 废话说完了，咱们现在就来看一下，将上面的各种组合做一个排列看看结果会是怎么样的？ 1.串行队列，同步执行 运行结果 执行结果可以清楚的看到全在主线程执行，并且是按照顺序执行，循环结束之后主线程的打印才输出。 2.串行队列，异步执行 运行结果 结果显示，系统开了1条异步线程，因此全部在线程3执行，并且是顺序执行。主线程打印虽然在最上面，但是这个先后顺序是不确定，如果睡个0.001秒，主线程的打印会混在中间。 3.并发队列，异步执行运行结果 结果显示，主线程的打印还是混在中间不确定的，因为异步线程就是谁也不等谁,可以同时执行。系统开了多条线程，并且执行的顺序也是乱序的 4.并发队列，同步执行运行结果 这个运行结果和第1种的串行队列，同步执行是一模一样的。 因为同步任务的概念就是不允许单开线程，在这里虽然他是并发的，可以允许程序同时运行，但是系统只有一条线程，所以他只能按照顺序执行，所以一旦是同步执行的，前面是什么队列都不重要了。 5.主队列，异步执行运行结果 结果显示有点出人意料。主线程在睡会之后才打印，循环一直在等着。因为主队列的任务虽然会加到主线程中执行，但是如果主线程里也有任务就必须等主线程任务执行完才轮到主队列的。 6.主队列，同步执行 运行结果运行结果为程序崩溃崩溃的原因是循环等待，主队列的东西要等主线程执行完，因为是同步执行不能开线程，并且同步里面的内容必须按照顺序依次执行，所以下面的任务要等上面的任务执行完才能执行，所以卡死。这是排列组合中唯一一个会卡死的组合。 7.同步任务的使用场景运行结果 结果显示，“用户登陆”在主线程打印，后两个在异步线程打印。上面的“用户登陆”使用同步执行，后面的扣费和下载都是异步执行。所以“用户登陆”必须第一个打印出来不管等多久，然后后面的两个异步和主线程打印会不确定顺序的打印。这就是日常开发中，那些后面对其有依赖的必须要先执行的任务使用同步执行，然后反正都要执行先后顺序无所谓的使用异步执行。 8.block异步任务包裹同步任务运行结果 因为整个block是在异步执行的，所以即使里面“用户登陆”是同步执行，那也无法在主线程中执行，只能开一条异步线程执行，后面我故意将一和二任务换了一下位置。在异步执行里面，因为项目是并发的，可以同时执行，而且查看动作在用户登录前面，所以它是可以比用户登录先执行也可能比用户登录后执行，但是因为用户登录是同步执行的，所以下载任务必须要等用户登录任务先执行完他才会执行，而主线程跟整个队列里面的任务之间，因为task是异步的，所以他们之间的先后顺序也是随机的，随意主线程执行的顺序可能在任何一个位置。 9.全局队列,异步执行运行结果 全局队列，实际上就相当于并发队列，所以并发队列异步执行，他会开启多条子线程去执行任务，并且他跟主线程之间的执行顺序也是随机的。 10.全局队列，同步执行运行结果 全局队列，同步执行，因为同步执行它不能开启新线程，所以所有的程序只能在主线程中按照顺序依次执行。全局队列的本质就是并发队列，只是在后面加入了，“服务质量”，和“调度优先级” 两个参数，这两个参数一般为了系统间的适配，最好直接填0和0。 总结： 1.开不开线程，取决于执行任务的函数，同步不开,并且同步会阻塞线程等到同步任务执行完以后才会执行其他任务，异步开,异步不会阻塞线程。 2.开几条线程，取决于队列，串行开一条，并发开多条(异步) 3.主队列： 专门用来在主线程上调度任务的”队列”，主队列不能在其他线程中调度任务！ 4.如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待 5.同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。 6.全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。","tags":[{"name":"同步","slug":"同步","permalink":"https://github.com/LiuFuBo1991/tags/同步/"},{"name":"异步","slug":"异步","permalink":"https://github.com/LiuFuBo1991/tags/异步/"},{"name":"串行","slug":"串行","permalink":"https://github.com/LiuFuBo1991/tags/串行/"},{"name":"并发","slug":"并发","permalink":"https://github.com/LiuFuBo1991/tags/并发/"}]},{"title":"如何填补友盟分享新浪微博的那些坑","date":"2017-07-06T10:51:15.000Z","path":"2017/07/06/如何填补友盟分享新浪微博的那些坑/如何填补友盟分享新浪微博的那些坑/","text":"前端时间听人说友盟分享更加简单、专业一些，然后我就开始尝试通过友盟来写一个分享的demo，因为，新浪微博分享是不要真机测试也能进行分享的，所以，在毫不知情的情况下，慢慢的就走进了那些坑。 废话不多说，现在把怎样实现一个新浪微博的分享给大家演示一遍。希望能给后面的童鞋起到一起抛砖引玉的效果。 一：首先，友盟分享要想成功，你得导入像QQ、微信、新浪微博、短信等第三方的白名单，我一开始就是被这个给坑了，拿着友盟的官方文档和demo，就开始埋头苦干，结果就是打死也分享不成功，到处问别人，才听说有要加白名单这回事，这才找到了文档加白名单的地方。 下面那个就是友盟分享文档加白名单的地方，你只需要按照他上面的提示把你的info.plist文件以source.code的形式打开，再把那些白名单加进去就行了。 当然，加入白名单以后，你就算是过了第一关，跳过了一个坑。这个时候，如果你想要给自己的APP瘦身的话，你按照下面的方式去操作 好，已经过了一关了，想想是不是有点小激动，不过，不要太开心，这只是一个开始。接下来我们就要开始进行新浪微博的分享了，首先你如果想要进行新浪微博的分享，那你就必须得到新浪的官网去注册一个应用的appkey 和appsecret,登录网址：http://open.weibo.com，一般申请的时候要填写你个人所在公司，还有身份证号码以及身份证正反面照片啥的，这个申请流程，各位童鞋可以自行脑补，反正我当时是嫌麻烦，就用的他官方demo的appkey来用的。反正是用来实验的，何必那么认真呢！ 这些工作完成以后，我们就要导入友盟的分享的SDK了，话不用说，大家都应该知道有两种方法（手动导入、cocoaPods导入）你只需要选择其中一种就好了。两种方法我都试过了，这里我推荐使用cocoaPods来导入，这样不用自己去配置那些链接库啥的，不容易出错。 通过cocoaPods导入，首先在你终端中今日你分享项目的目录并且查询友盟分享当前有那些版本: 在这么多版本中你要选择比较新的一个版本，我是选择的4.3这个版本，然后我们就可以在vim中去配置关于友盟的信息： 然后再安装4.3版本的友盟分享SDK，只要出现了complete就表示完成了。 这个时候，我们再到AppDelegate.m文件中加上两个头文件 #import “UMSocial.h” —-&gt;这个头文件是关于友盟的 #import “UMSocialSinaSSOHandler.h” —–&gt;这个头文件是关于新浪微博的 下面的appkey对应什么意思都有代码，照着这样写就行了。 我们在处理新浪微博SSO授权以及微信分享完成以后还要跳转回当前app来，所以还要加入下面两端代码 在这里，你还得在你项目的info-&gt;URL Types里面添加一个URL Schemes进去 添加完上面的代码，AppDelegate.m里面的代码算是全部写完了，现在你只需要集成分享功能的视图源码UIViewController.m，把如下代码复制并粘贴到你将弹出一个分享列表的位置后面，例如到响应分享按钮的方法中调用它。并且修改下面的友盟appkey，你要分享的文字、图片，你要分享到的微博平台，例如下面写的是新浪微博、腾讯微博、人人网。 你如果还想要知道你是否分享成功，你还可以调用以下方法 到这里，基本上一个完整的新浪微博分享就成功了，但是还有一个最大的坑等着你去填呢，我花了好久才解决的就是这个大坑。因为新浪微博注册的时候你要上传你的app的bundle id，所以你当前项目的bundle id必须跟你申请新浪微博的bundle id一致，不然的话，就会发生分享授权不成功，出现闪退的现象。","tags":[{"name":"分享","slug":"分享","permalink":"https://github.com/LiuFuBo1991/tags/分享/"},{"name":"第三方","slug":"第三方","permalink":"https://github.com/LiuFuBo1991/tags/第三方/"}]},{"title":"button横向自动排布的几种方式","date":"2017-07-06T10:44:13.000Z","path":"2017/07/06/button横向自动排布的几种方式/button横向自动排布的几种方式/","text":"第一种方式:根据屏幕的宽度，然后计算一排能够放下多少个Button然后再来排布 {for (int i=0; i&lt;_dataSources.count; i++) { NSInteger rowCount = 0; if (SCREENWIDTH &gt;320) { rowCount =(SCREENWIDTH - 46)/90 + 1; }else{ rowCount =(SCREENWIDTH - 46)/90; } UIButton *perButton = [[UIButton alloc]init]; perButton.tag = i+100; [perButton setTitle:_dataSources[i] forState:UIControlStateNormal]; perButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1); [perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; perButton.layer.cornerRadius = 5; perButton.layer.masksToBounds = YES; [self addSubview:perButton]; if (i&lt;=(rowCount -1)) { [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23); if (i== 0) { make.left.equalTo(self.mas_left).with.offset(23); }else if(i&gt; 0 &amp;&amp; i&lt;= rowCount - 1){ make.left.mas_equalTo(i*93 + 23); } make.width.mas_equalTo(70); make.height.mas_equalTo(34); }]; if (i == rowCount - 1 ) { _signCount = i; } }else if(i&gt;(rowCount-1)){ UIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100]; [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(topButton.mas_bottom).with.offset(15); if(i%rowCount == 0){ make.left.equalTo(self.mas_left).with.offset(23); } else if(i%rowCount &gt; 0){ make.left.mas_equalTo((i%rowCount)*93 + 23); } make.width.mas_equalTo(70); make.height.mas_equalTo(32); }]; if (SCREENWIDTH &gt; 320 &amp;&amp; i%rowCount == 3) { _signCount = i; }else if(SCREENWIDTH == 320 &amp;&amp; i%rowCount == 2){ _signCount = i; } } } } 第二种：确定好第一排放多少个，然后把距离两边的边路设置好，中间的间隙自动改变：{for (int i=0; i&lt;_dataSources.count; i++) { NSInteger rowCount =3; UIButton *perButton = [[UIButton alloc]init]; perButton.tag = i+100; [perButton setTitle:_dataSources[i] forState:UIControlStateNormal]; perButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1); [perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; perButton.layer.cornerRadius = 5; perButton.layer.masksToBounds = YES; [self addSubview:perButton]; if (i&lt;=(rowCount -1)) { [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23); if (i== 0) { make.left.equalTo(self.mas_left).with.offset(23);//(/3/2) }else if(i == 1){ make.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2); }else if(i == 2){ make.right.equalTo(self.mas_right).with.offset(-23); } make.width.mas_equalTo(72); make.height.mas_equalTo(34); }]; if (i == rowCount - 1 ) { _signCount = i; } }else if(i&gt;(rowCount-1)){ UIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100]; [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(topButton.mas_bottom).with.offset(15); if(i%rowCount == 0){ make.left.equalTo(self.mas_left).with.offset(23); } else if(i%rowCount == 1){ make.left.equalTo(self.mas_left).with.offset(95 + (SCREENWIDTH - 262)/2); }else if(i%rowCount == 2){ make.right.equalTo(self.mas_right).with.offset(-23); } make.width.mas_equalTo(72); make.height.mas_equalTo(32); }]; if(i%rowCount == 2){ _signCount = i; } } } } 第三种:确定好第一排能放多少个，然后设置没一个间隙的间距都相同:{for (int i=0; i&lt;_dataSources.count; i++) { NSInteger rowCount =3; UIButton *perButton = [[UIButton alloc]init]; perButton.tag = i+100; [perButton setTitle:_dataSources[i] forState:UIControlStateNormal]; perButton.backgroundColor = NM_COLOR_RGB(244, 155, 56, 1); [perButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; perButton.layer.cornerRadius = 5; perButton.layer.masksToBounds = YES; [self addSubview:perButton]; if (i&lt;=(rowCount -1)) { [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.timelimitLabel.mas_bottom).with.offset(23); if (i== 0) { make.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4);//(/3/2) }else if(i == 1){ make.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2); }else if(i == 2){ make.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4)); } make.width.mas_equalTo(72); make.height.mas_equalTo(34); }]; if (i == rowCount - 1 ) { _signCount = i; } }else if(i&gt;(rowCount-1)){ UIButton *topButton = (UIButton *)[self viewWithTag:_signCount+100]; [perButton mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(topButton.mas_bottom).with.offset(15); if(i%rowCount == 0){ make.left.equalTo(self.mas_left).with.offset((SCREENWIDTH - 216)/4); } else if(i%rowCount == 1){ make.left.equalTo(self.mas_left).with.offset(72 + (SCREENWIDTH - 216)/2); }else if(i%rowCount == 2){ make.right.equalTo(self.mas_right).with.offset(-((SCREENWIDTH - 216)/4)); } make.width.mas_equalTo(72); make.height.mas_equalTo(32); }]; if(i%rowCount == 2){ _signCount = i; } } } }","tags":[]},{"title":"对NSString字符串全部API作解释","date":"2017-07-06T09:13:19.000Z","path":"2017/07/06/对NSString字符串全部API作解释/对NSString字符串全部API作解释/","text":"iOS8最新API和一些生僻API，做了红色标注，便于大家查阅 0.定义一个无符号整型 两个字节 范围[0,65535] {typedef unsigned short unichar;} 1.提前进入以下六个类告诉编译器，六个都是类的名称 @class NSData,NSArray,NSDictionary,NSCharacterSet,NSURL,NSError,NSLocale; 2.异常处理字符串，控制台出错信息报告 {FOUNDATION_EXPORTNSString *const NSParseErrorException;} 3.宏定义下字符串的最大值 {#define NSMaximumStringLength (INT_MAX-1)} 4.字符串进行比较 options typedef NS_OPTIONS(NSUInteger, NSStringCompareOptions) { NSCaseInsensitiveSearch =1,// 两个 字符串的比较不区分大小写 NSLiteralSearch = 2,//两个字符串的 比较区分大小写 NSBackwardsSearch =4,//从字符串末尾开发查询搜索 NSAnchoredSearch =8,//搜索有限制范围的字符串 NSNumericSearch = 64,//根据字符串里的数字来计算顺序 NSDiacriticInsensitiveSearchNS_ENUM_AVAILABLE(10_5,2_0) =128, NSWidthInsensitiveSearch NS_ENUM_AVAILABLE(10_5,2_0) =256,//可以忽略字符串的宽度（长度） 比较结果 NSForcedOrderingSearchNS_ENUM_AVAILABLE(10_5,2_0) =512,// 忽略不区分大小写比较的选项 NSRegularExpressionSearchNS_ENUM_AVAILABLE(10_7,3_2) =1024 // }; 5.字符串编码的多种选项 enum {NSASCIIStringEncoding =1,/ 0..127 only / NSNEXTSTEPStringEncoding =2,NSJapaneseEUCStringEncoding =3,NSUTF8StringEncoding =4,NSISOLatin1StringEncoding =5,NSSymbolStringEncoding =6,NSNonLossyASCIIStringEncoding =7,NSShiftJISStringEncoding =8, / kCFStringEncodingDOSJapanese /NSISOLatin2StringEncoding =9,NSUnicodeStringEncoding =10,NSWindowsCP1251StringEncoding = 11, / Cyrillic; same as AdobeStandardCyrillic /NSWindowsCP1252StringEncoding =12, / WinLatin1 / NSWindowsCP1253StringEncoding =13, / Greek / NSWindowsCP1254StringEncoding =14, / Turkish / NSWindowsCP1250StringEncoding =15, / WinLatin2 / NSISO2022JPStringEncoding = 21, / ISO 2022 Japanese encoding for e-mail /NSMacOSRomanStringEncoding =30,NSUTF16StringEncoding = NSUnicodeStringEncoding, / An alias for NSUnicodeStringEncoding / NSUTF16BigEndianStringEncoding = 0x90000100, / NSUTF16StringEncoding encoding with explicit endianness specified /NSUTF16LittleEndianStringEncoding = 0x94000100, / NSUTF16StringEncoding encoding with explicit endianness specified /NSUTF32StringEncoding =0x8c000100, NSUTF32BigEndianStringEncoding = 0x98000100, / NSUTF32StringEncoding encoding with explicit endianness specified /NSUTF32LittleEndianStringEncoding = 0x9c000100 / NSUTF32StringEncoding encoding with explicit endianness specified / }; 6.字符串编码 {typedefNSUInteger NSStringEncoding;} 字符串编码转换条件option，下面指定缓冲区转换会用到 { typedef NS_OPTIONS(NSUInteger, NSStringEncodingConversionOptions) { NSStringEncodingConversionAllowLossy =1, NSStringEncodingConversionExternalRepresentation =2 }; //7.字符转化异常 FOUNDATION_EXPORTNSString *const NSCharacterConversionException; //8. NSString继承NSObject，并遵守以下三个协议 @interface NSString :NSObject//9.只读属性字符串长度length @property (readonly)NSUInteger length; } 7.选取字符串对应下表的字符 { -(unichar)characterAtIndex:(NSUInteger)index;} 8.字符串的init初始化方法 {-(instancetype)initNS_DESIGNATED_INITIALIZER;} 9.当一个xib的控件被加载实例化的时候，系统会默认调用这个方法。 {- (instancetype)initWithCoder:(NSCoder *)aDecoderNS_DESIGNATED_INITIALIZER;} 10.NSString的扩展方法 {@interface NSString (NSStringExtensionMethods)} 11.截取字符串的指定段 {- (void)getCharacters:(unichar *)buffer range:(NSRange)aRange;} 12.截取指定位置Index之后字符串 {- (NSString *)substringFromIndex:(NSUInteger)from;} 13.从索引0第一个字符串开始，截取指定长度的字符串 {- (NSString *)substringToIndex:(NSUInteger)to;} 14.截取字符串的指定段，返回值为NSString {- (NSString *)substringWithRange:(NSRange)range;} 15.比较两个字符串 {- (NSComparisonResult)compare:(NSString *)string;} 16.比较两个字符串，并加上条件 {- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;} 17.比较两个字符串，并加上某些条件到指定段 {- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;} 18.比较两个字符串，并加上某些条件还有本地化语言环境，在指定段进行比较 {- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale;} 19.不区分大小写比较字符串 {- (NSComparisonResult)caseInsensitiveCompare:(NSString *)string;} 20.本地化比较字符串 {- (NSComparisonResult)localizedCompare:(NSString *)string;} 21.不区分大小写以及本地化比较字符串 {- (NSComparisonResult)localizedCaseInsensitiveCompare:(NSString *)string;} 22.本地化标准字符串比较，返回升序降序相等 {- (NSComparisonResult)localizedStandardCompare:(NSString *)stringNS_AVAILABLE(10_6,4_0);} 23.比较两个字符串是否相等 {- (BOOL)isEqualToString:(NSString *)aString;} 24.测试字符串是否以aString开头 {- (BOOL)hasPrefix:(NSString *)aString;} 25.测试字符串是否以aString结尾 {- (BOOL)hasSuffix:(NSString *)aString;} 26.判断字符串A是否包含aString字符串B，返回值Bool {- (BOOL)containsString:(NSString *)aStringNS_AVAILABLE(10_10,8_0);} 27.这是iOS8的新特性API 判断字符串A是否包含字符串B，不区分大小写，返回Bool 例： { NSSsring * stringA = @“abcd”; NSSsring * stringB = @“d”; BOOl test = [stringA localizedCaseInsensitiveContainsString:stringB]; 输出打印值 YES - (BOOL)localizedCaseInsensitiveContainsString:(NSString *)aString NS_AVAILABLE(10_10, 8_0);} 28.搜索一个字符串是否包含某个字符 rangeOfString前面的参数是要被搜索的字符串，后面的是要搜索的字符 {- (NSRange)rangeOfString:(NSString *)aString;} 29.搜索一个字符串是否包含某个字符，并添加筛选条件option {- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;} 30.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range {- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange;} 31.搜索一个字符串是否包含某个字符，添加筛选条件以及搜索的范围range,最后还有本地化的设置 {- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)localeNS_AVAILABLE(10_5,2_0);} 32.指定字符集进行搜索 {- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet;} 33.指定字符集进行搜索，并且加上某些限制条件 {- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask;} 34.指定字符集进行搜索，并且加上某些限制条件，且在指定的位置段进行 {- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)searchRange;} 35.用字符串的字符编码指定索引查找位置 {- (NSRange)rangeOfComposedCharacterSequenceAtIndex:(NSUInteger)index;} 36.用字符串的字符编码指定区域段查找位置 {- (NSRange)rangeOfComposedCharacterSequencesForRange:(NSRange)rangeNS_AVAILABLE(10_5,2_0);} 37.将aString字符串添加到前面字符串A的后面 {- (NSString *)stringByAppendingString:(NSString *)aString;} 38.将多个字符串添加到前面字符串A的后面 {- (NSString *)stringByAppendingFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);} 39.只读属性 double类型 {@property (readonly)double doubleValue;} 40.只读属性 float类型 {@property (readonly)float floatValue;} 41.只读属性int类型 {@property (readonly)int intValue;} 42.只读属性NSInteger类型 {@property (readonly)NSInteger integerValueNS_AVAILABLE(10_5,2_0);} 43.只读属性long long 类型 {@property (readonly)longlong longLongValueNS_AVAILABLE(10_5,2_0);} 44.只读属性BOOL类型 {@property (readonly)BOOL boolValueNS_AVAILABLE(10_5,2_0);} 45.将字符串根据传进来的字符串参数separator进行分割，并转化成数组 {- (NSArray *)componentsSeparatedByString:(NSString *)separator;} 46.将字符串根据传进来的字符编码separator进行分割，并拆分成数组返回 {- (NSArray *)componentsSeparatedByCharactersInSet:(NSCharacterSet *)separatorNS_AVAILABLE(10_5,2_0);} {- (NSString *)commonPrefixWithString:(NSString *)aString options:(NSStringCompareOptions)mask;} 47.将字符串的所有字符转化成大写 {@property (readonly,copy)NSString *uppercaseString;} 48.将字符串的所有字符转化为小写 {@property (readonly,copy)NSString *lowercaseString;} 49.所有单词的首字母转化成大写 {@property (readonly,copy)NSString *capitalizedString;} 50.所有字符转化成大写 本地化 {- (NSString *)uppercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);} 51.所有字符串转化成小写 本地化 {- (NSString *)lowercaseStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);} 52.所有单词首字母转化成大写 本地化 {- (NSString *)capitalizedStringWithLocale:(NSLocale *)localeNS_AVAILABLE(10_8,6_0);} 53.删除字符串中包含字符集部分的字符 返回字符串 扩展一下，如果想要删除字符串前后的空格或者回车，这样做： {[stringA stringByTrimmingCharactersInSet: [NSCharacterSetWhitespaceAndNewLineCharacterSet]]; - (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;} 54.将字符串padString指定索引段添加到前面字符串后面 {- (NSString *)stringByPaddingToLength:(NSUInteger)newLength withString:(NSString *)padString startingAtIndex:(NSUInteger)padIndex;} 55.指定段分行去字符串 {- (void)getLineStart:(NSUInteger *)startPtr end:(NSUInteger *)lineEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;} 56.返回字符串指定段位置和长度 {- (NSRange)lineRangeForRange:(NSRange)range;} 57.给字符串指定段分段取字符串 {- (void)getParagraphStart:(NSUInteger *)startPtr end:(NSUInteger *)parEndPtr contentsEnd:(NSUInteger *)contentsEndPtr forRange:(NSRange)range;} 58.指定段分段的位置和长度 {- (NSRange)paragraphRangeForRange:(NSRange)range;} 59. {typedefNS_OPTIONS(NSUInteger, NSStringEnumerationOptions) { // Pass in one of the &quot;By&quot; options: NSStringEnumerationByLines =0, // Equivalent to lineRangeForRange: NSStringEnumerationByParagraphs =1, // Equivalent to paragraphRangeForRange: NSStringEnumerationByComposedCharacterSequences =2, // Equivalent to rangeOfComposedCharacterSequencesForRange: NSStringEnumerationByWords =3, NSStringEnumerationBySentences =4, // ...and combine any of the desired additional options: NSStringEnumerationReverse =1UL &lt;&lt;8, NSStringEnumerationSubstringNotRequired =1UL &lt;&lt;9, NSStringEnumerationLocalized =1UL &lt;&lt;10 // User&apos;s default locale };} 60.检查是否在指定范围内是否有匹配的字符串 {- (void)enumerateSubstringsInRange:(NSRange)range options:(NSStringEnumerationOptions)opts usingBlock:(void (^)(NSString *substring,NSRange substringRange,NSRange enclosingRange, BOOL *stop))blockNS_AVAILABLE(10_6,4_0);} 61.列举枚举字符串所有行 {- (void)enumerateLinesUsingBlock:(void (^)(NSString *line,BOOL *stop))block NS_AVAILABLE(10_6,4_0);} 62.字符串 {@property (readonly,copy)NSString *description;} 63.返回字符串哈希地址 {@property (readonly)NSUInteger hash;} 64.字符串最快编码值 {@property (readonly)NSStringEncoding fastestEncoding;} 65.字符串最小编码值 {@property (readonly)NSStringEncoding smallestEncoding; } 66.返回指定编码的NSData对象 {- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding allowLossyConversion:(BOOL)lossy; // External representation} 67.返回指定编码的NSData对象 {- (NSData *)dataUsingEncoding:(NSStringEncoding)encoding; // External representation} 68.判断是否可以无损化转码 {- (BOOL)canBeConvertedToEncoding:(NSStringEncoding)encoding;} 69.char编码转化 {- (__strongconstchar *)cStringUsingEncoding:(NSStringEncoding)encodingNS_RETURNS_INNER_POINTER;} 70.C字符串转化是够成功 {- (BOOL)getCString:(char *)buffer maxLength:(NSUInteger)maxBufferCount encoding:(NSStringEncoding)encoding;// NO return if conversion not} 71.指定缓存区转换 {- (BOOL)getBytes:(void *)buffer maxLength:(NSUInteger)maxBufferCount usedLength:(NSUInteger *)usedBufferCount encoding:(NSStringEncoding)encoding options:(NSStringEncodingConversionOptions)options range:(NSRange)range remainingRange:(NSRangePointer)leftover;} 72.字符串编码时需要用的字节长度 {- (NSUInteger)maximumLengthOfBytesUsingEncoding:(NSStringEncoding)enc;} 73.字符串编码时需要用到最大字节长度 {- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;} 74.unicode范式D标准化 {@property (readonly,copy)NSString *decomposedStringWithCanonicalMapping;} 75.unicode范式c标准化 {@property (readonly,copy)NSString *precomposedStringWithCanonicalMapping;} 76.unicode范式KD标准化 {@property (readonly,copy)NSString *decomposedStringWithCompatibilityMapping;} 77.unicode范式KC标准化 {@property (readonly,copy)NSString *precomposedStringWithCompatibilityMapping;} 78.本地化字符串折叠 {- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale NS_AVAILABLE(10_5,2_0);} 79.字符串的指定区域段被有条件的替换掉 {- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRangeNS_AVAILABLE(10_5,2_0);} 80.字符串的特定字符串被替换掉 {- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);} 81.将字符串的指定区域段字符串被替换掉 {- (NSString *)stringByReplacingCharactersInRange:(NSRange)range withString:(NSString *)replacement NS_AVAILABLE(10_5,2_0);} 82.将字符串转化为char类型 {@property (readonly)__strongconstchar *UTF8StringNS_RETURNS_INNER_POINTER;} 83.默认C字符串编码 {+ (NSStringEncoding)defaultCStringEncoding;} 84.可用的字符串编码 {+ (constNSStringEncoding *)availableStringEncodings;} 85.编码的名称vheng {+ (NSString *)localizedNameOfStringEncoding:(NSStringEncoding)encoding;} 86.指定缓冲区，编码和字节长度初始化NSString对象 {- (instancetype)initWithCharactersNoCopy:(unichar *)characters length:(NSUInteger)length freeWhenDone:(BOOL)freeBuffer;} 87.指定unichar字符，字节长度初始化NSString对象 {- (instancetype)initWithCharacters:(constunichar *)characters length:(NSUInteger)length;} 88.转化为NSString对象 {- (instancetype)initWithUTF8String:(constchar *)nullTerminatedCString;} 89.指定字符串初始化为NSString对象 {- (instancetype)initWithString:(NSString *)aString;} 90.格式化多个字符串初始化NSString对象 {- (instancetype)initWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);} 91.格式化字符串初始化NSString对象 {- (instancetype)initWithFormat:(NSString *)format arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);} 92.本地化格式化多个字符串初始化NSString对象 {- (instancetype)initWithFormat:(NSString *)format locale:(id)locale, ...NS_FORMAT_FUNCTION(1,3);} 93.本地化格式化字符串初始化NSString对象 {- (instancetype)initWithFormat:(NSString *)format locale:(id)locale arguments:(va_list)argListNS_FORMAT_FUNCTION(1,0);} 94.指定编码转化NSData数据 {- (instancetype)initWithData:(NSData *)data encoding:(NSStringEncoding)encoding;} 95.指定编码和字节数初始化NSString对象 {- (instancetype)initWithBytes:(constvoid *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding;} 96.指定缓冲区，编码和字节数初始化NSString对象 {- (instancetype)initWithBytesNoCopy:(void *)bytes length:(NSUInteger)len encoding:(NSStringEncoding)encoding freeWhenDone:(BOOL)freeBuffer;} 97.初始化空字符串 {+ (instancetype)string;} 98.初始化NSString字符串 {+ (instancetype)stringWithString:(NSString *)string;} 99.返回指定长度unichar的C字符串 {+ (instancetype)stringWithCharacters:(constunichar *)characters length:(NSUInteger)length;} 100.转化C字符串为UTF8串 {+ (instancetype)stringWithUTF8String:(constchar *)nullTerminatedCString;} 101.初始化NSString对象昂，这种创建方式会自动释放内存，很常用的一种方式 {+ (instancetype)stringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);} 102.初始化NSString自动释放内存，本地化 {+ (instancetype)localizedStringWithFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);} 103.初始化C字符串并且指定编码，在这里需要手动释放内存（init） {- (instancetype)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;} 104.初始化C字符串并且指定编码，在这里需要自动释放内存 {+ (instancetype)stringWithCString:(constchar *)cString encoding:(NSStringEncoding)enc;} 105.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，已经知道编码 {- (instancetype)initWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;} 106.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，已经知道编码 {- (instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;} 107.读取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，已经知道编码 {+ (instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;} 108.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，已经知道编码 {+ (instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;} 109.读取URL地址数据转化为字符串并且指定编码，在这里init创建需要手动释放内存，不知道编码 {- (instancetype)initWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;} 110.读取FILE地址数据转化为字符串并且指定编码，同样需要手动释放内存，不知道编码 {- (instancetype)initWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;} 111.取URL地址数据转化为字符串并且指定编码，，这里会自动释放内存，不知道编码 {+ (instancetype)stringWithContentsOfURL:(NSURL *)url usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;} 112.读取FILE地址数据转化为字符串并且指定编码，这里也会自定释放内存，不知道编码 {+ (instancetype)stringWithContentsOfFile:(NSString *)path usedEncoding:(NSStringEncoding *)enc error:(NSError **)error;} 113.将数据写入URL并且指定编码 {- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;} 114.将数据写入文件并且指定编码 {- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error; @end @interface NSMutableString :NSString} 115.使用aString替换前面字符串的指定区域字符 {- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;} @end 116.可变字符串的扩展方法 {@interface NSMutableString (NSMutableStringExtensionMethods)} 117.插入字符串aString，在指定的loc位置 {- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc;} 118.删除指定区域段的字符串 {- (void)deleteCharactersInRange:(NSRange)range;} 119.追加字符串aString {- (void)appendString:(NSString *)aString;} 120.追加多个字符串 {- (void)appendFormat:(NSString *)format, ...NS_FORMAT_FUNCTION(1,2);} 121.设置新的aString {- (void)setString:(NSString *)aString;} 122.初始化一个容量为capacity大小的字符串，并且需要手动释放内存 {- (NSMutableString *)initWithCapacity:(NSUInteger)capacity;} 123.初始化一个容量为capacity大小的字符串，但是不用手动释放内存，这些提前指定的容量，知识用于内存优化，实际大小可以大于设置的容量capacity {+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;} 124.指定限制条件，指定区段中的replacement替换成target {- (NSUInteger)replaceOccurrencesOfString:(NSString *)target withString:(NSString *)replacement options: (NSStringCompareOptions)options range:(NSRange)searchRange;} @end 125.关于字符串编码检测的扩展 {@interface NSString (NSStringEncodingDetection)} 126.对一份data数据进行转换为字符串，有可选option字典，另外还有是否允许有损失，最终转换之后返回一个编码种类。下面是7种不同option字典选项 {+ (NSStringEncoding)stringEncodingForData:(NSData *)data encodingOptions:(NSDictionary *)opts convertedString:(NSString **)string usedLossyConversion:(BOOL *)usedLossyConversion NS_AVAILABLE(10_10, 8_0); @end FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionSuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0); // NSArray of NSNumbers which contain NSStringEncoding values; if this key is not present in the dictionary, all encodings are considered FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionDisallowedEncodingsKeyNS_AVAILABLE(10_10,8_0); // NSNumber boolean value; if this key is not present in the dictionary, the default value is NO FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionUseOnlySuggestedEncodingsKeyNS_AVAILABLE(10_10,8_0); // NSNumber boolean value; if this key is not present in the dictionary, the default value is YES FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionAllowLossyKeyNS_AVAILABLE(10_10,8_0); // NSNumber boolean value; if this key is not present in the dictionary, the default value is NO FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionFromWindowsKeyNS_AVAILABLE(10_10,8_0); FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLossySubstitutionKeyNS_AVAILABLE(10_10,8_0); FOUNDATION_EXPORTNSString *const NSStringEncodingDetectionLikelyLanguageKeyNS_AVAILABLE(10_10,8_0); @interface NSString (NSExtendedStringPropertyListParsing)} 127.将字符串转化为属性列表 {例如：NSString * stringA = [NSString stringWithFormat:@“Name =xulin ; age = 23;”]; NSLog(@“%@”,[stringA propertyList]); 控制台输出为{ Name = xulin ; age = 23; } - (id)propertyList;} 128.字符串转化为字典 {NSDictionary * dictionary = [stringA propertyListFromStringFileFormat]; NSLog(@“%@”,dictionary); 控制台输出为{ Name = xulin ; age = 23; } - (NSDictionary *)propertyListFromStringsFileFormat @end} 129.下面是一些弃用代码。也就是上面所翻译过的代码。 {@interface NSString (NSStringDeprecated) - (constchar *)cStringNS_RETURNS_INNER_POINTERNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (constchar *)lossyCStringNS_RETURNS_INNER_POINTER NS_DEPRECATED(10_0,10_4,2_0, 2_0); - (NSUInteger)cStringLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (void)getCString:(char *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLengthNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (void)getCString:(char *)bytes maxLength:(NSUInteger)maxLength range:(NSRange)aRange remainingRange:(NSRangePointer)leftoverRange NS_DEPRECATED(10_0, 10_4, 2_0, 2_0); - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFileNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomicallyNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (id)initWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (id)initWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0); + (id)stringWithContentsOfFile:(NSString *)pathNS_DEPRECATED(10_0,10_4,2_0, 2_0); + (id)stringWithContentsOfURL:(NSURL *)urlNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (id)initWithCStringNoCopy:(char *)bytes length:(NSUInteger)length freeWhenDone:(BOOL)freeBufferNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (id)initWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (id)initWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0); + (id)stringWithCString:(constchar *)bytes length:(NSUInteger)lengthNS_DEPRECATED(10_0,10_4,2_0, 2_0); + (id)stringWithCString:(constchar *)bytesNS_DEPRECATED(10_0,10_4,2_0, 2_0); - (void)getCharacters:(unichar *)buffer; @end enum { NSProprietaryStringEncoding =65536 /* Installation-specific encoding */ }; #if !defined(_OBJC_UNICHAR_H_) #define _OBJC_UNICHAR_H_ #endif #define NS_UNICHAR_IS_EIGHT_BIT 0 @interface NSSimpleCString :NSString { @package char *bytes; int numBytes; #if __LP64__ int _unused; #endif } @end @interface NSConstantString :NSSimpleCString @end #if __LP64__ #else externvoid *_NSConstantStringClassReference; #endif }","tags":[{"name":"API","slug":"API","permalink":"https://github.com/LiuFuBo1991/tags/API/"}]},{"title":"高德地图的使用技巧","date":"2017-07-06T09:02:50.000Z","path":"2017/07/06/高德地图的使用技巧/高德地图的使用技巧/","text":"第一步:在iOS8.0以后，使用高德地图的时候首先要进行配置plist文件 这两个字段是ios8.0以后缺省的字段，他主要的意思是提示用户授权使用地图定位时候的提示语。 第二步:在配置好plist文件以后就是正式的使用高德地图进行定位了因为XCode本身就已经集成了高德地图进来，所以用户就没有必要自己去集成高德地图的SDK到项目中了，当然，如果你自己手动集成到项目中，也是可以的。首先我们如果只是需要进行定位的话，那就要了解CoreLocation:定位框架，它在没有地图时也可以使用定位.而在CoreLocation中，我们需要运用到CLLocationManager这个类，他是定位必须要用到的一个类。首先我们先初始化一个CLLocationManager类型的对象,并且给他设置代理。 第三步:在创建了这个类以后，我们还必须要设置是否能开启定位服务，因此需要给locationServicesEnabled这个属性设置为YES。 第四步:设置好以后，我们就需要实现代理方法了，首先是实现获取定位信息的代理方法 第五步：当定位发生错误，就会触发该代理方法 第六步：当这些步骤都完成了，我们就可以写一个接口供外界调用开始定位，或者一开始就开启定位.如果只是为了简单的调用定位接口来获取当前位置信息，那么用以上的方式就已经足够了，如果需要进行地图显示并且进行导航等功能的实现，那就需要去了解一下MapKit这个框架了。 未完待续…","tags":[{"name":"地图","slug":"地图","permalink":"https://github.com/LiuFuBo1991/tags/地图/"}]},{"title":"NSClassFromString,NSSelectorFromString...","date":"2017-07-06T08:58:02.000Z","path":"2017/07/06/NSClassFromString-NSSelectorFromString/NSClassFromString-NSSelectorFromString/","text":"NSClassFromString这个方法判断类是否存在，如果存在就动态加载的，不存为就返回一个空对象; id myObj = [[NSClassFromString(@”MyClass”) alloc] init]; 正常情况下等价于：id myObj = [[MyClass alloc] init]; 优点： 1， 弱化连接，因此并不会把没有的Framework也link到程序中。 2，不需要使用import，因为类是动态加载的，只要存在就可以加载。因此如果你的toolchain中没有某个类的头文件定义，而你确信这个类是可以用的，那么也可以用这种方法。 NSSelectorFromString这个方法是上个方法的补充，也是动态加载实例方法。 SEL sel = NSSelectorFromString(@”doSomethingMethod:”)//注意这个冒号,说明方法带有参数 if([object respondsToSelector:sel]) { [object performSelector:sel withObject:color]; //注意如果有两个参数,使用两个withObject:参数; } isKindOfClassisKindOfClass 我们也可以使用isKindOfClass来检查一个对象是否是一个类的成员 isMemberOfClassisMemberOfClass方法是来确定对象是否是某一个类的成员 initWithCoder和initWithFrame的区别 initWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用. initWithFrame是由用户创建的UIView子类，实例时被调用 UIView autoresizingMask如果视图的autoresizesSubviews属性声明被设置为YES，则其子视图会根据autoresizingMask属性的值自动进行尺寸调整。简单配置一下视图的自动尺寸调整掩码常常就能使应用程序得到合适的行为；否则，应用程序就必须通过重载layoutSubviews方法来提供自己的实现。 self.autoresizingMask = UIViewAutoresizingFlexibleWidth;//这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。 UIViewAutoresizingNone 这个常量如果被设置，视图将不进行自动尺寸调整。 UIViewAutoresizingFlexibleHeight 这个常量如果被设置，视图的高度将和父视图的高度一起成比例变化。否则，视图的高度将保持不变。 UIViewAutoresizingFlexibleWidth 这个常量如果被设置，视图的宽度将和父视图的宽度一起成比例变化。否则，视图的宽度将保持不变。 UIViewAutoresizingFlexibleLeftMargin 这个常量如果被设置，视图的左边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的左边界的相对位置将保持不变。 UIViewAutoresizingFlexibleRightMargin 这个常量如果被设置，视图的右边界将随着父视图宽度的变化而按比例进行调整。否则，视图和其父视图的右边界的相对位置将保持不变。 UIViewAutoresizingFlexibleBottomMargin 这个常量如果被设置，视图的底边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的底边界的相对位置将保持不变。 UIViewAutoresizingFlexibleTopMargin 这个常量如果被设置，视图的上边界将随着父视图高度的变化而按比例进行调整。否则，视图和其父视图的上边界的相对位置将保持不变。","tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/LiuFuBo1991/tags/技术/"}]},{"title":"JavaScriptCore的巨坑（JSExportAs方式绑定的本地通信）","date":"2017-07-06T08:42:37.000Z","path":"2017/07/06/JavaScriptCore的巨坑/JavaScriptCore的巨坑/","text":"前言本篇分享的类型不是学习教程，并且要有一点JavaScriptCore基础， 毕竟这一块网上一大堆的学习教程，博主就没必要班门弄斧了。 本篇的目的是分享JavaScriptCore中用JSExport协议和JSExportAs宏来进行js和oc通信的两个大坑。 1.内存泄露 2.调用-[JSValue callWithArguments]野指针问题 注: 用block方式来进行js和oc的通信没这两个大坑。 第一个坑：内存泄露一般绑定JSContext里的native的写法都是self.context[@”native”] = self。但是这样写会产生内存泄露（泄露原理就是互相持有了），这个坑随便百度Google一下也能找到很多解决方案。目前博主的解决方案是native指定一个新的对象，然后在指定对象里实现JSExport协议。贴上博主在项目里用到的核心代码 : 和js通信的控制器页面核心代码{// 以 JSExport 协议关联 native 的方法 self.context[@&quot;native&quot;] = [[NMFormFlowWapNativeManager alloc] initWithDelegate:self];} NMFormFlowWapNativeManager.h{@interface NMFormFlowWapNativeManager : NSObject - (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate; @property (nonatomic,weak) id&lt;NMFormFlowWapNativeManagerDelegate&gt; delegate; @end} NMFormFlowWapNativeManager.m{@import JavaScriptCore; @protocol TestJSExport &lt;JSExport&gt; JSExportAs(nativeCall, - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jstype); @end @interface NMFormFlowWapNativeManager () &lt;TestJSExport&gt; @end @implementation NMFormFlowWapNativeManager - (instancetype)initWithDelegate:(id&lt;NMFormFlowWapNativeManagerDelegate&gt;)delegate { if (self = [super init]) { self.delegate = delegate; } return self; } - (void)nativeCallHandleWithType:(NSString *)nativeType parameter:(NSString *)parameter jsType:(NSString *)jsType { NSDictionary *dicParams = [NSJSONSerialization JSONObjectWithData:[parameter dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableLeaves error:nil]; [self.delegate nativeCallHandleWithThread:webThread type:nativeType parameter:dicParams jsType:jsType]; }} PS:代码并不是完整的，但最核心的关键已经贴上来了。顺便简单解释一下。由于native管理的对象交给了另一个，所以在管理者对象里新开了一个代理回调。方便在控制器那边接收得到JS的事件。只要有点基础的，一看就懂了。毕竟本篇不是学习教程，而是分享坑的。 第二个坑：-[JSValue callWithArguments]野指针问题这个问题有点奇葩，JSValue的callWithArguments就是oc调用js函数所执行的方法。那这简单的函数怎么发生野指针问题尼。那就是oc进行网络请求，请求完回调的时候调用JSValue的callWithArguments的方法就是产生野指针，而且是间接性的，有时候会有时候不会。一旦崩溃基本都直接飞去main函数了。。。。 这个问题百度Google都找了许久也没找到类似的问题和解决方案。只是崩溃的时候，左边的堆栈提示webThread（当时猜测可能是线程间通信影响的此问题），然后我蒙一下切换到webView的线程里去调用callWithArguments函数试试，结果就从未发生过崩溃了。 例子：假设，h5上有一个图片显示和一个button，点击button的时候，调用本地摄像头并且上传图片到服务器，上传完之后在调用js一个函数，告诉js图片上传成功，让js去做对应的逻辑。这个时候网络请求完回调里的线程是主线程，调用callWithArguments的时候，就会间接性的崩溃。 解决方案解决办法就是回到webView的线程去调用callWithArguments就不会崩溃（因为js和oc绑定的函数，在函数里执行的代码不是在主线程里执行的）。模拟代码： {///假设这个函数是和js的test函数绑定的。如果监听到这个函数就进行网络请求或者上传图片等操作。 - (void)test { //获取webView线程，因为js和oc绑定的函数里执行的代码不是在主线程里。 NSThread *webThread = [NSThread currentThread]; //网络请求 @weakify(self); [HTTPRequest requestGetTokenWithFinished:^(void){ @strongify(self); //通知js请求完了。 //正常情况下是直接在这里调用，但是会间接性发生野指针问题，差不多每隔四五次发生一次野指针。 //JSValue *jsCall = self.context[@&quot;jsCall&quot;]; //[jsCall callWithArguments:nil]; //线程安全的，用此方式，笔者再也没发生过野指针问题。 [self performSelector:@selector(jsCall) onThread:webThread withObject:nil waitUntilDone:NO]; }]; } - (void)jsCall { JSValue *jsCall = self.context[@&quot;jsCall&quot;]; [jsCall callWithArguments:nil]; }} 结语总之笔者分享此文章的主要目的是第二个野指针问题，因为笔者在Google和stackoverflow里也找了很久也找不到问题原因，然后都是蒙对的，所以才来进行分享。可能对于不懂JavaScriptCore看起来有点困难，总之可以先了解一下。而对于js和oc的通信的业务不复杂的或者使用block进行通信的，应该很难遇到此问题。再者，网上很多学习教程基本都是推荐callWithArguments在主线程里调用，但目前笔者认为应该还是让它在webView的线程里去执行（那个野指针问题就是在主线程里执行所发生的）。 而callWithArguments野指针问题的底层实际发生原理也并不是很清楚。所以目前只能说博主是怎么解决的，但是为什么…..博主也不知其然了。有知道的方便的话也可告知一下。 而对于demo…..笔者也想写，但对于html、js并不是很熟悉（顶多看得懂几个标签）。所以….无能为力奉上demo了。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/LiuFuBo1991/tags/javascript/"}]},{"title":"性能检测要怎么玩才尽兴","date":"2017-07-06T08:18:35.000Z","path":"2017/07/06/性能检测要怎么玩才尽兴/性能检测要怎么玩才尽兴/","text":"前言: 相信大家平时在利用xcode调试bug的时候经常性的遇到一些莫名其妙的问题，其中就包括崩溃了，打全局断点也不崩溃到某一行，而是直接报野指针的问题，像这种不能具体定位到错误在某一行的代码是最难找到问题的。现在我们可以通过打全局断点，然后xcode自带的内存检测工具来找到问题可能出现的地方。 打开一个XCode项目，最好是连上真机来测试，这里如果你xcode已经升级到了8.0以上，那么你就必须要有证书才能进行真机调试了。如果在XCode7上面，你是可以直接进行真机测试的。连上手机以后，选择produc-&gt;profile进入XCode自带的调试工具选择页面。 如下图:选择完以后的样式如下图: 我们可以从上面看到箭头所指的四个地方，一个是Allocations-&gt;这个是关于UI布局方面的检测，第二个是Core Animation 这个是关于动画方面的检测，通过Core Animation可以检测到他的帧数，从而判断是不是卡，是否需要进一步完善动画。第三个Leaks就是我们用的最多的内存泄露检测，通过这个，我们可以大致锁定哪些地方可能有内存泄露，然后直接找到有内存泄露的地方，这样可以非常方便我们找到哪里有问题。第四个Time Profiler 这个是检测事件的工具，比如按钮的触发事件等等这些。接下来讲解如何使用它们。 这里列举如何使用Leaks这个内存检测工具。 1.首先点开Leaks这个工具，然后选中左上角的Leaks检测选项 2.点击开始运行 3.选择Call tress以一个树形结构来展示 4.在右下角Call Tree选项中选择Separate by Thread 和 Hide System Libraries这两个，其他的展示没研究深刻，没用过，这样我们点击页面就可以看到那些地方有问题，然后我们双击有问题的那个类，就可以找到对应的代码，通过进入xcode去检查就行了。 如图:通过上面的过程以后双击6步骤得到结果如下: 然后我们可以看到在第一步中我们能看到哪里有问题，然后点击步骤二，就可以直接到达XCode中，这句代码对应的地方，这样就可以找到可能有问题的地方，从而检查出我们项目是否有问题了。 检测动画方面，其实方法也差不多，只是选项不太一样而已。最后选项如图： 我们需要了解两个两个区域： 这里记录了实时的fps数值，有些地方是0是因为屏幕没有滑动 这是重中之重，接下来我会带大家逐个理解、体验这些调试选项 有过游戏经验的人也许对fps这个概念比较熟悉。我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。根据不同选项可以找到问题，这里我们一项一项的来为大家讲解每一项代表的意思. 1.Color Blended Layers 这个是图层颜色混合的意思. 基本概念: 我们要明白 像素 的概念。屏幕上每一个点都是一个像素点，颜色由R、G、B、alpha组成。如果某一块区域上覆盖了多层layer，最后所计算出来的显示的颜色效果，会受到这些layer的共同影响。举个例子：上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blended)需要消耗一定的GPU资源，在实际开发中可能不止只有两层。如果只想显示最上层的颜色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。 Core Animation Instrucment 类似如下图，可以通过Instrucments来选择Core Animation查看FPS：注意:如果要看FPS,需要在真机上运行 Demo优化前 在优化之前，我们通过设置如下方式，可以看到有好多混合的地方，红色部分都是影响滚动时流畅性的。 Demo优化后 优化后，我们看到没有中文标签变成绿色了，而有中文的标签还是混合后的颜色。关于有中文的标签如何去优化，这个问题现在没有办法，如果大家有什么好的方法，请一定要告诉我。 优化的代码 在优化前，cell的标题的背景颜色并没有手动设置，而是使用了默认的颜色，这时候即使我们的标题是没有中文的，也会出现混合。而笔者只是添加了一行代码： {self.titleLabel.backgroundColor = self.contentView.backgroundColor;} 这么一行代码，使得标签的背景色和父视图的背景颜色一样，就只可以解决混合的问题（中文除外）。 如何我们设置背景色为clear，一样会出现混合，即使父视图也是clear。 同样，我们在配置CollectionViewCell的时候，也是这么处理： 我们设置cell的背景色、collectionview的背景色都为白色，然后titleLabel的背景色与父视图的背景色设置成一样，这样就可以解决混合问题，中文文本除外。 我们尝试设置opaque、alpha都会是图层混合，因此最关键的还是backgroundColor这一关键属性。在实际开发中海油很多控件需要我们注意，这里只是简单介绍。 2.Color Hits Green and Misses Red 光栅化 光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。demo中的这一行代码表示将label的layer光栅化： {label.layer.shouldRasterize = YES;} 如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 光栅化的核心在于缓存的思想。我们自己动手把玩一下，可以发现以下几个有意思的现象： 上下微小幅度滑动时，一直是绿色 上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色 如果静止一秒钟，刚开始滑动时会变红。 这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。 光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化，所以我们做的第二个优化是注释掉下面这行代码： {label.layer.shouldRasterize = YES;} 光栅化会 导致离屏渲染，这个下面会讲解。 概念理解 OpenGL中，GPU屏幕渲染有以下两种方式： On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 离屏渲染的是是非非 相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 1.创建新缓冲区；要想进行离屏渲染，首先要创建一个新的缓冲区。 2上下文切换；离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 离屏渲染触发方式 设置了以下属性时，都会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。按照之前的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：cpu渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。 3.Color Offscreen Rendered Yellow 开启以后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。如下图: 如果没有进行第二步优化，你会发现label也是黄色。可以看到tabbar和statusBar也是黄色，这是因为它们使用了模糊效果。图片也是黄色，这说明它也进行了离屏渲染，观察源码后发现主要原因是它使用了阴影，接下来我们进行第四个优化，在设置阴影效果的四行代码下面添加一行： 这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。 设置cornerRadius本身并不会导致离屏渲染，但很多时候它还需要配合layer.masksToBounds = true使用。根据之前的总结，设置masksToBounds会导致离屏渲染。解决方案是尽可能在滑动时避免设置圆角，如果必须设置圆角，可以使用光栅化技术将圆角缓存起来： 4.Color Copied images 这个是用来检测图片的格式转化的，比如应用中有一些从网络下载的图片，而GPU恰好不支持这个格式，这就需要CPU预先进行格式转化。第三个选项“Color Copied Images”就用来检测这种实时的格式转化，如果有则会将图片标记为蓝色。如果调试时发现有图片被标记为蓝色，说明图片格式有问题。 5.Color Misaligned images 意思就是当图片的像素和目标控件的像素不对齐，就会放一个洋红色的图层在图片上，当图片的像素大小与控件的大小不一致而导致需要缩放时，图片会呈现黄色。 6.Color Compositing Fast Path Blue 标记由硬件标记的路径。蓝色越多越好。 7.Flash Updated Regions 这个选项会对重绘的内容高亮成黄色（也就是任何在软件层面使用Core Graphics绘制的图层）。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者说通过增加缓存或者使用替代方案会有提升性能的空间。 注:文章灵感来自同事，如有转载，请注明出处；谢谢。","tags":[{"name":"Instruments","slug":"Instruments","permalink":"https://github.com/LiuFuBo1991/tags/Instruments/"},{"name":"性能检测","slug":"性能检测","permalink":"https://github.com/LiuFuBo1991/tags/性能检测/"}]},{"title":"cocoaPods升级后遇到的巨坑","date":"2017-07-06T08:03:08.000Z","path":"2017/07/06/cocoaPods升级后遇到的巨坑/cocoaPods升级后遇到的巨坑/","text":"之前我的CocoaPods一直是在0.0.39这个版本中，一直都处于相安无事的状态，后来看到同事将CocoaPods升级到1.1.1正式版本以后，我也跟着装逼，然后就一不小心装逼失败，把CocoaPods升级到最新的bata版本了，最后又搞了半天把版本降为了1.1.1版本。感觉自己棒棒哒，过了年来，完蛋了，出问题了。现在我就完全复现出错的整个流程以及解决办法，帮助有需要的人。 一：假设我们现在需要安装最新版本AFNetworking,第一步肯定是在终端导入地址 二:在导入项目地址以后，我们开始查询AFNetworking有哪些版本，选中我们需要的版本 三：选中我们需要的那个版本，并复制版本号 四：配置Podfile文件 五：配置后是这样，然后保存Podfile文件 六:开始安装AFNetworking,这下你会发现报错了，完蛋了，好紧张，怎么办？最后，我们在通过查询资料以后发现。CocoaPods升级后，Podfile文件的内容格式要求发生了变化，必须指出指出所用第三方库的target。没有办法，只能指定对应的target,我查询了一下网上的办法是这样的。他这样也能实现，但是我觉得还是挺麻烦的，其实我们只需要在配置podfile文件之前创建一个podfile文件以后，他就会自动的生成指定了target的podfile文件。先创建podfile文件以后，打开pod file文件，你看到的就是这个样子这个就是需要指定的target的标准格式，系统自己就可以帮你生成，完全不用你去动手敲，最后一步，安装AFNetworking成功备注：虽然写的繁琐，但是重点是为了把问题讲清楚，希望能给被这个问题带来困惑的人给予帮助，大神勿喷，谢谢！","tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/LiuFuBo1991/tags/技术/"},{"name":"cocoaPods","slug":"cocoaPods","permalink":"https://github.com/LiuFuBo1991/tags/cocoaPods/"},{"name":"终端","slug":"终端","permalink":"https://github.com/LiuFuBo1991/tags/终端/"}]},{"title":"如果通过cocoaPods创建私有库","date":"2017-07-06T07:27:16.000Z","path":"2017/07/06/如果通过cocoaPods创建私有库/如果通过cocoaPods创建私有库/","text":"在写代码的时候，有时候封装了一个很好的工具类，系统在以后的项目中也能够被使用，但是每次使用的时候，都需要拷贝代码，感觉很麻烦，所以，我希望能够将这些代码通过cocoaPods来进行托管，这样只需要通过cocoaPods来导入就行了。 一：咱们第一步需要在github上面创建一个仓库来存储代码 二:点击创建项目以后，咱们需要将代码上传到仓库中，现在在本地创建一个用于装demo和工具类的文件夹 三：创建文件夹以后，将文件夹拖入sourcetree并将其添加远程仓库 四：然后在本地创建的文件夹中创建Demo以及工具类文件夹 五：将本地代码上传到github上面，上传完以后是这个样子 六:配置podspec文件,这个文件你可以通过命令创建，也可以通过拷贝过来再进行修改，但是请注意，不要用文本对该文件进行编辑，否则最后该文件将不能正常使用。这里我是用sublime Text 2这款软件打开的 七：配置好以后，就把该配置文件上传到github上面，成功后多了一个podspec文件 八:新建一个项目，并将其通过cocoaPods导入项目 九：执行过后，结果就是这样,此时该工具类已经通过cocoaPods导入我们项目中了 十：打开Xcode就可以使用该工具类了 续：如果你的工具类还关联其他第三方公开库的话，只需要将podspec改成如下形式","tags":[{"name":"技术","slug":"技术","permalink":"https://github.com/LiuFuBo1991/tags/技术/"},{"name":"私有库","slug":"私有库","permalink":"https://github.com/LiuFuBo1991/tags/私有库/"}]},{"title":"抓包工具charles","date":"2017-07-06T07:12:03.000Z","path":"2017/07/06/抓包工具charles/抓包工具charles/","text":"前言:在任何时候，利用好工具总会给我们生活带来意想不到的惊喜，所谓磨刀不误砍柴工就是这个道理，平时开发的过程中，我们很多时候都是通过NSLog打印来获得结果费时又费力，最近刚好发现一款抓包软件还是挺好用的，只需要简单的设置以后就可以抓取所有的网络请求信息了。 一:抓取电脑上的包1.需要设置一下charles2.进入设置页面勾选相应选项就可以使用了。 二:抓取手机上的包1.首相将charles的设置里面端口号设置为88882.在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 88883.设置好以后会弹出一个请求连接的弹出框，选择allow就可以愉快的抓取你想要的数据了。","tags":[{"name":"工具","slug":"工具","permalink":"https://github.com/LiuFuBo1991/tags/工具/"}]}]